'use server'

import { createClient } from '@/lib/supabase/server'
import { revalidatePath } from 'next/cache'
import type { ResponsibleActor } from '@/types/database'

type CreateCaseResult = {
  data: any | null
  error: string | null
}

type ActionResult<T = unknown> = {
  data?: T
  error?: string
}

export async function createCase(
  customerId: string,
  responsibleActor: ResponsibleActor
): Promise<CreateCaseResult> {
  const supabase = await createClient()

  // Verify customer exists and has customer role
  const { data: profile, error: profileError } = await supabase
    .from('profiles')
    .select('role')
    .eq('id', customerId)
    .single()

  if (profileError || !profile) {
    return {
      data: null,
      error: 'Customer not found',
    }
  }

  if (profile.role !== 'customer') {
    return {
      data: null,
      error: 'User must have customer role',
    }
  }

  // Create case (case_number auto-generated by DB)
  const { data: newCase, error: caseError } = await supabase
    .from('cases')
    .insert({
      customer_id: customerId,
      responsible_actor: responsibleActor,
      status: 'waiting_for_data',
    })
    .select()
    .single()

  if (caseError) {
    return {
      data: null,
      error: caseError.message,
    }
  }

  return {
    data: newCase,
    error: null,
  }
}

/**
 * Block a case with an engineer message
 * Story 4.2: Block Case with Engineer Message
 */
export async function blockCase(
  caseId: string,
  blockingMessage: string
): Promise<ActionResult> {
  try {
    const supabase = await createClient()

    // Verify user is authenticated
    const {
      data: { user },
      error: authError
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { error: 'Unauthorized - please login' }
    }

    // Verify user is an engineer
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profile?.role !== 'engineer') {
      return { error: 'Unauthorized - only engineers can block cases' }
    }

    // Validate blocking message
    if (!blockingMessage || blockingMessage.trim().length < 10) {
      return { error: 'Blocking message must be at least 10 characters' }
    }

    // Get current case to validate status
    const { data: currentCase, error: fetchError } = await supabase
      .from('cases')
      .select('status')
      .eq('id', caseId)
      .single()

    if (fetchError) {
      return { error: 'Case not found' }
    }

    if (currentCase.status !== 'data_submitted') {
      return { error: `Cannot block case with status '${currentCase.status}'. Case must be in 'data_submitted' status.` }
    }

    // Update case status to blocked with message
    const { data: updatedCase, error: updateError } = await supabase
      .from('cases')
      .update({
        status: 'blocked',
        engineer_blocking_message: blockingMessage.trim(),
        updated_at: new Date().toISOString()
      })
      .eq('id', caseId)
      .select()
      .single()

    if (updateError) {
      console.error('Error blocking case:', updateError)
      return { error: 'Failed to block case' }
    }

    // Revalidate case detail page and dashboard
    revalidatePath(`/cases/${caseId}`)
    revalidatePath('/dashboard')

    return { data: updatedCase }
  } catch (error) {
    console.error('Unexpected error in blockCase:', error)
    return { error: 'An unexpected error occurred' }
  }
}

/**
 * Complete a case
 * Story 4.3: Complete Case (simplified - no PDF upload for MVP)
 */
export async function completeCase(caseId: string): Promise<ActionResult> {
  try {
    const supabase = await createClient()

    // Verify user is authenticated
    const {
      data: { user },
      error: authError
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { error: 'Unauthorized - please login' }
    }

    // Verify user is an engineer
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profile?.role !== 'engineer') {
      return { error: 'Unauthorized - only engineers can complete cases' }
    }

    // Get current case to validate status
    const { data: currentCase, error: fetchError } = await supabase
      .from('cases')
      .select('status')
      .eq('id', caseId)
      .single()

    if (fetchError) {
      return { error: 'Case not found' }
    }

    if (currentCase.status !== 'data_submitted') {
      return { error: `Cannot complete case with status '${currentCase.status}'. Case must be in 'data_submitted' status.` }
    }

    // Update case status to completed
    const { data: updatedCase, error: updateError } = await supabase
      .from('cases')
      .update({
        status: 'completed',
        completed_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      })
      .eq('id', caseId)
      .select()
      .single()

    if (updateError) {
      console.error('Error completing case:', updateError)
      return { error: 'Failed to complete case' }
    }

    // Revalidate case detail page and dashboard
    revalidatePath(`/cases/${caseId}`)
    revalidatePath('/dashboard')

    return { data: updatedCase }
  } catch (error) {
    console.error('Unexpected error in completeCase:', error)
    return { error: 'An unexpected error occurred' }
  }
}

/**
 * Assign an expert to a case
 * Epic 7: Expert Assignment (Manual MVP)
 */
export async function assignExpert(
  caseId: string,
  expertId: string
): Promise<ActionResult> {
  try {
    const supabase = await createClient()

    // Verify user is authenticated
    const {
      data: { user },
      error: authError
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { error: 'Unauthorized - please login' }
    }

    // Verify user is an engineer
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', user.id)
      .single()

    if (profile?.role !== 'engineer') {
      return { error: 'Unauthorized - only engineers can assign experts' }
    }

    // Verify expert exists and has expert role
    const { data: expertProfile } = await supabase
      .from('profiles')
      .select('role')
      .eq('id', expertId)
      .single()

    if (!expertProfile || expertProfile.role !== 'expert') {
      return { error: 'Invalid expert - user must have expert role' }
    }

    // Update case with assigned expert
    const { data: updatedCase, error: updateError } = await supabase
      .from('cases')
      .update({
        assigned_expert_id: expertId,
        updated_at: new Date().toISOString()
      })
      .eq('id', caseId)
      .select()
      .single()

    if (updateError) {
      console.error('Error assigning expert:', updateError)
      return { error: 'Failed to assign expert' }
    }

    // Revalidate pages
    revalidatePath(`/cases/${caseId}`)
    revalidatePath('/dashboard')

    return { data: updatedCase }
  } catch (error) {
    console.error('Unexpected error in assignExpert:', error)
    return { error: 'An unexpected error occurred' }
  }
}

/**
 * Submit building data widget and change case status to 'data_submitted'
 * Epic 3: Building Data Collection
 */
export async function submitBuildingData(
  caseId: string,
  widgetData: {
    tab1_data: any
    tab2_data: any
    tab3_data: any
    tab4_data: any
    tab5_data: any
    tab6_data: any
    tab7_file_ids: string[]
  }
): Promise<ActionResult> {
  try {
    const supabase = await createClient()

    // Verify user is authenticated
    const {
      data: { user },
      error: authError
    } = await supabase.auth.getUser()

    if (authError || !user) {
      return { error: 'Unauthorized - please login' }
    }

    // Check if case_data already exists and preserve file IDs
    const { data: existingData } = await supabase
      .from('case_data')
      .select('id, tab7_file_ids')
      .eq('case_id', caseId)
      .maybeSingle()

    // Preserve existing file IDs (don't overwrite with empty array from widget)
    const fileIds = existingData?.tab7_file_ids || []

    if (existingData) {
      // Update existing record - preserve file IDs
      const { error: updateError } = await supabase
        .from('case_data')
        .update({
          tab1_data: widgetData.tab1_data,
          tab2_data: widgetData.tab2_data,
          tab3_data: widgetData.tab3_data,
          tab4_data: widgetData.tab4_data,
          tab5_data: widgetData.tab5_data,
          tab6_data: widgetData.tab6_data,
          // Keep existing file IDs
          tab7_file_ids: fileIds,
          submitted_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('case_id', caseId)

      if (updateError) {
        console.error('Error updating case_data:', updateError)
        return { error: 'Failed to save building data' }
      }
    } else {
      // Insert new record
      const { error: insertError } = await supabase
        .from('case_data')
        .insert({
          case_id: caseId,
          tab1_data: widgetData.tab1_data,
          tab2_data: widgetData.tab2_data,
          tab3_data: widgetData.tab3_data,
          tab4_data: widgetData.tab4_data,
          tab5_data: widgetData.tab5_data,
          tab6_data: widgetData.tab6_data,
          tab7_file_ids: fileIds,
          submitted_at: new Date().toISOString()
        })

      if (insertError) {
        console.error('Error inserting case_data:', insertError)
        return { error: 'Failed to save building data' }
      }
    }

    // Update case status to data_submitted
    const { data: updatedCase, error: caseUpdateError } = await supabase
      .from('cases')
      .update({
        status: 'data_submitted',
        updated_at: new Date().toISOString()
      })
      .eq('id', caseId)
      .select()
      .single()

    if (caseUpdateError) {
      console.error('Error updating case status:', caseUpdateError)
      return { error: 'Data saved but failed to update case status' }
    }

    // Revalidate pages
    revalidatePath(`/cases/${caseId}`)
    revalidatePath('/dashboard')

    return { data: updatedCase }
  } catch (error) {
    console.error('Unexpected error in submitBuildingData:', error)
    return { error: 'An unexpected error occurred' }
  }
}
